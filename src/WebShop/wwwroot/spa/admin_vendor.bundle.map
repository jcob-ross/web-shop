{"version":3,"sources":["webpack:///admin_vendor.bundle.js","webpack:///./Client/admin_vendor.ts","webpack:///./~/rxjs/add/operator/switchMap.js","webpack:///./~/rxjs/operator/switchMap.js"],"names":["webpackJsonp","0","module","exports","__webpack_require__","735","Observable_1","switchMap_1","Observable","prototype","switchMap","757","project","resultSelector","this","lift","SwitchMapOperator","__extends","d","b","__","constructor","p","hasOwnProperty","Object","create","OuterSubscriber_1","subscribeToResult_1","call","subscriber","source","_subscribe","SwitchMapSubscriber","_super","destination","index","_next","value","result","error","_innerSub","innerSubscription","unsubscribe","add","subscribeToResult","_complete","isUnsubscribed","_unsubscribe","notifyComplete","innerSub","remove","isStopped","notifyNext","outerValue","innerValue","outerIndex","innerIndex","_tryNotifyNext","next","err","OuterSubscriber"],"mappings":"AAAAA,cAAc,IAERC,EACA,SAASC,EAAQC,EAASC,GAE/B,YCJDA,GAAO,KACPA,EAAO,KACPA,EAAO,GACPA,EAAO,IACPA,EAAO,IACPA,EAAO,KACPA,EAAO,KAGPA,EAAO,KACPA,EAAO,KACPA,EAAO,KACPA,EAAO,KACPA,EAAO,KACPA,EAAO,KACPA,EAAO,KACPA,EAAO,KACPA,EAAO,KAEPA,EAAO,KDaDC,IACA,SAASH,EAAQC,EAASC,GElChC,YACA,IAAAE,GAAAF,EAAA,GACAG,EAAAH,EAAA,IACAE,GAAAE,WAAAC,UAAAC,UAAAH,EAAAG,WFyCMC,IACA,SAAST,EAAQC,EAASC,GG7ChC,YAuDA,SAAAM,GAAAE,EAAAC,GACA,MAAAC,MAAAC,KAAA,GAAAC,GAAAJ,EAAAC,IAvDA,GAAAI,GAAAH,WAAAG,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBN,KAAAO,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAT,UAAA,OAAAU,EAAAK,OAAAC,OAAAN,IAAAC,EAAAX,UAAAU,EAAAV,UAAA,GAAAW,KAEAM,EAAAtB,EAAA,IACAuB,EAAAvB,EAAA,GAmDAD,GAAAO,WACA,IAAAM,GAAA,WACA,QAAAA,GAAAJ,EAAAC,GACAC,KAAAF,UACAE,KAAAD,iBAKA,MAHAG,GAAAP,UAAAmB,KAAA,SAAAC,EAAAC,GACA,MAAAA,GAAAC,WAAA,GAAAC,GAAAH,EAAAf,KAAAF,QAAAE,KAAAD,kBAEAG,KAOAgB,EAAA,SAAAC,GAEA,QAAAD,GAAAE,EAAAtB,EAAAC,GACAoB,EAAAL,KAAAd,KAAAoB,GACApB,KAAAF,UACAE,KAAAD,iBACAC,KAAAqB,MAAA,EAwDA,MA7DAlB,GAAAe,EAAAC,GAOAD,EAAAvB,UAAA2B,MAAA,SAAAC,GACA,GAAAC,GACAH,EAAArB,KAAAqB,OACA,KACAG,EAAAxB,KAAAF,QAAAyB,EAAAF,GAEA,MAAAI,GAEA,WADAzB,MAAAoB,YAAAK,SAGAzB,KAAA0B,UAAAF,EAAAD,EAAAF,IAEAH,EAAAvB,UAAA+B,UAAA,SAAAF,EAAAD,EAAAF,GACA,GAAAM,GAAA3B,KAAA2B,iBACAA,IACAA,EAAAC,cAEA5B,KAAA6B,IAAA7B,KAAA2B,kBAAAd,EAAAiB,kBAAA9B,KAAAwB,EAAAD,EAAAF,KAEAH,EAAAvB,UAAAoC,UAAA,WACA,GAAAJ,GAAA3B,KAAA2B,iBACAA,OAAAK,gBACAb,EAAAxB,UAAAoC,UAAAjB,KAAAd,OAGAkB,EAAAvB,UAAAsC,aAAA,WACAjC,KAAA2B,kBAAA,MAEAT,EAAAvB,UAAAuC,eAAA,SAAAC,GACAnC,KAAAoC,OAAAD,GACAnC,KAAA2B,kBAAA,KACA3B,KAAAqC,WACAlB,EAAAxB,UAAAoC,UAAAjB,KAAAd,OAGAkB,EAAAvB,UAAA2C,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAP,GACAnC,KAAAD,eACAC,KAAA2C,eAAAJ,EAAAC,EAAAC,EAAAC,GAGA1C,KAAAoB,YAAAwB,KAAAJ,IAGAtB,EAAAvB,UAAAgD,eAAA,SAAAJ,EAAAC,EAAAC,EAAAC,GACA,GAAAlB,EACA,KACAA,EAAAxB,KAAAD,eAAAwC,EAAAC,EAAAC,EAAAC,GAEA,MAAAG,GAEA,WADA7C,MAAAoB,YAAAK,MAAAoB,GAGA7C,KAAAoB,YAAAwB,KAAApB,IAEAN,GACCN,EAAAkC","file":"admin_vendor.bundle.js","sourcesContent":["webpackJsonp([6],{\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t// Angular 2\r\n\t__webpack_require__(113);\r\n\t__webpack_require__(377);\r\n\t__webpack_require__(1);\r\n\t__webpack_require__(40);\r\n\t__webpack_require__(36);\r\n\t__webpack_require__(251);\r\n\t__webpack_require__(114);\r\n\t// RxJS\r\n\t__webpack_require__(267);\r\n\t__webpack_require__(132);\r\n\t__webpack_require__(178);\r\n\t__webpack_require__(268);\r\n\t__webpack_require__(269);\r\n\t__webpack_require__(735);\r\n\t__webpack_require__(396);\r\n\t__webpack_require__(397);\r\n\t__webpack_require__(177);\r\n\t__webpack_require__(33);\r\n\tif (true) {\r\n\t}\r\n\telse {\r\n\t}\r\n\n\n/***/ },\n\n/***/ 735:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(6);\n\tvar switchMap_1 = __webpack_require__(757);\n\tObservable_1.Observable.prototype.switchMap = switchMap_1.switchMap;\n\t//# sourceMappingURL=switchMap.js.map\n\n/***/ },\n\n/***/ 757:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar OuterSubscriber_1 = __webpack_require__(73);\n\tvar subscribeToResult_1 = __webpack_require__(75);\n\t/**\n\t * Projects each source value to an Observable which is merged in the output\n\t * Observable, emitting values only from the most recently projected Observable.\n\t *\n\t * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n\t * these inner Observables using {@link switch}.</span>\n\t *\n\t * <img src=\"./img/switchMap.png\" width=\"100%\">\n\t *\n\t * Returns an Observable that emits items based on applying a function that you\n\t * supply to each item emitted by the source Observable, where that function\n\t * returns an (so-called \"inner\") Observable. Each time it observes one of these\n\t * inner Observables, the output Observable begins emitting the items emitted by\n\t * that inner Observable. When a new inner Observable is emitted, `switchMap`\n\t * stops emitting items from the earlier-emitted inner Observable and begins\n\t * emitting items from the new one. It continues to behave like this for\n\t * subsequent inner Observables.\n\t *\n\t * @example <caption>Rerun an interval Observable on every click event</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * @see {@link concatMap}\n\t * @see {@link exhaustMap}\n\t * @see {@link mergeMap}\n\t * @see {@link switch}\n\t * @see {@link switchMapTo}\n\t *\n\t * @param {function(value: T, ?index: number): Observable} project A function\n\t * that, when applied to an item emitted by the source Observable, returns an\n\t * Observable.\n\t * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n\t * A function to produce the value on the output Observable based on the values\n\t * and the indices of the source (outer) emission and the inner Observable\n\t * emission. The arguments passed to this function are:\n\t * - `outerValue`: the value that came from the source\n\t * - `innerValue`: the value that came from the projected Observable\n\t * - `outerIndex`: the \"index\" of the value that came from the source\n\t * - `innerIndex`: the \"index\" of the value from the projected Observable\n\t * @return {Observable} An Observable that emits the result of applying the\n\t * projection function (and the optional `resultSelector`) to each item emitted\n\t * by the source Observable and taking only the values from the most recently\n\t * projected inner Observable.\n\t * @method switchMap\n\t * @owner Observable\n\t */\n\tfunction switchMap(project, resultSelector) {\n\t    return this.lift(new SwitchMapOperator(project, resultSelector));\n\t}\n\texports.switchMap = switchMap;\n\tvar SwitchMapOperator = (function () {\n\t    function SwitchMapOperator(project, resultSelector) {\n\t        this.project = project;\n\t        this.resultSelector = resultSelector;\n\t    }\n\t    SwitchMapOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n\t    };\n\t    return SwitchMapOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar SwitchMapSubscriber = (function (_super) {\n\t    __extends(SwitchMapSubscriber, _super);\n\t    function SwitchMapSubscriber(destination, project, resultSelector) {\n\t        _super.call(this, destination);\n\t        this.project = project;\n\t        this.resultSelector = resultSelector;\n\t        this.index = 0;\n\t    }\n\t    SwitchMapSubscriber.prototype._next = function (value) {\n\t        var result;\n\t        var index = this.index++;\n\t        try {\n\t            result = this.project(value, index);\n\t        }\n\t        catch (error) {\n\t            this.destination.error(error);\n\t            return;\n\t        }\n\t        this._innerSub(result, value, index);\n\t    };\n\t    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n\t        var innerSubscription = this.innerSubscription;\n\t        if (innerSubscription) {\n\t            innerSubscription.unsubscribe();\n\t        }\n\t        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n\t    };\n\t    SwitchMapSubscriber.prototype._complete = function () {\n\t        var innerSubscription = this.innerSubscription;\n\t        if (!innerSubscription || innerSubscription.isUnsubscribed) {\n\t            _super.prototype._complete.call(this);\n\t        }\n\t    };\n\t    SwitchMapSubscriber.prototype._unsubscribe = function () {\n\t        this.innerSubscription = null;\n\t    };\n\t    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        this.remove(innerSub);\n\t        this.innerSubscription = null;\n\t        if (this.isStopped) {\n\t            _super.prototype._complete.call(this);\n\t        }\n\t    };\n\t    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n\t        if (this.resultSelector) {\n\t            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n\t        }\n\t        else {\n\t            this.destination.next(innerValue);\n\t        }\n\t    };\n\t    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n\t        var result;\n\t        try {\n\t            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.destination.next(result);\n\t    };\n\t    return SwitchMapSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\t//# sourceMappingURL=switchMap.js.map\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** admin_vendor.bundle.js\n **/","// Angular 2\r\nimport '@angular/platform-browser';\r\nimport '@angular/platform-browser-dynamic';\r\nimport '@angular/core';\r\nimport '@angular/common';\r\nimport '@angular/forms';\r\nimport '@angular/http';\r\nimport '@angular/router';\r\n\r\n// RxJS\r\nimport 'rxjs/add/Observable/of';\r\nimport 'rxjs/add/operator/map';\r\nimport 'rxjs/add/operator/mergeMap';\r\nimport 'rxjs/add/operator/catch';\r\nimport 'rxjs/add/operator/debounceTime';\r\nimport 'rxjs/add/operator/switchMap';\r\nimport 'rxjs/add/operator/do';\r\nimport 'rxjs/add/operator/filter';\r\nimport 'rxjs/add/operator/distinctUntilChanged';\r\n\r\nimport 'jquery';\r\n\r\ndeclare var ENV: any; // webpack DefinePlugin\r\nif ('production' === ENV) {\r\n  // Production\r\n\r\n} else {\r\n  // Development\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/angular2-template-loader!./Client/admin_vendor.ts\n **/","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar switchMap_1 = require('../../operator/switchMap');\nObservable_1.Observable.prototype.switchMap = switchMap_1.switchMap;\n//# sourceMappingURL=switchMap.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/operator/switchMap.js\n ** module id = 735\n ** module chunks = 6\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): Observable} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project, resultSelector) {\n    return this.lift(new SwitchMapOperator(project, resultSelector));\n}\nexports.switchMap = switchMap;\nvar SwitchMapOperator = (function () {\n    function SwitchMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapSubscriber = (function (_super) {\n    __extends(SwitchMapSubscriber, _super);\n    function SwitchMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapSubscriber.prototype._next = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (error) {\n            this.destination.error(error);\n            return;\n        }\n        this._innerSub(result, value, index);\n    };\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    SwitchMapSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.isUnsubscribed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return SwitchMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMap.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/switchMap.js\n ** module id = 757\n ** module chunks = 6\n **/"],"sourceRoot":""}